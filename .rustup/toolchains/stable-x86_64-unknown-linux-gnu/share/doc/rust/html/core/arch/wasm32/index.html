<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Platform-specific intrinsics for the `wasm32` platform."><meta name="keywords" content="rust, rustlang, rust-lang, wasm32"><title>core::arch::wasm32 - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize1.53.0.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc1.53.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light1.53.0.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark1.53.0.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu1.53.0.css" disabled ><script id="default-settings"></script><script src="../../../storage1.53.0.js"></script><script src="../../../crates1.53.0.js"></script><noscript><link rel="stylesheet" href="../../../noscript1.53.0.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon1.53.0.svg">
<link rel="alternate icon" type="image/png" href="../../../favicon-16x161.53.0.png">
<link rel="alternate icon" type="image/png" href="../../../favicon-32x321.53.0.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow1.53.0.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../core/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo1.53.0.png' alt='logo'></div></a><p class="location">Module wasm32</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><p class="location"><a href="../../index.html">core</a>::<wbr><a href="../index.html">arch</a></p><div id="sidebar-vars" data-name="wasm32" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../../brush1.53.0.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../../settings.html"><img src="../../../wheel1.53.0.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">core</a>::<wbr><a href="../index.html">arch</a>::<wbr><a class="mod" href="">wasm32</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/core/up/up/stdarch/crates/core_arch/src/mod.rs.html#168-171" title="goto source code">[src]</a></span></h1><div class="item-info"><div class="stab portability">This is supported on <strong>WebAssembly</strong> only.</div></div><div class="docblock"><p>Platform-specific intrinsics for the <code>wasm32</code> platform.</p>
<p>This module provides intrinsics specific to the WebAssembly
architecture. Here you’ll find intrinsics necessary for leveraging
WebAssembly proposals such as <a href="https://github.com/webassembly/threads">atomics</a> and <a href="https://github.com/webassembly/simd">simd</a>. These proposals are
evolving over time and as such the support here is unstable and requires
the nightly channel. As WebAssembly proposals stabilize these functions
will also become stable.</p>
<p>See the <a href="../index.html">module documentation</a> for general information
about the <code>arch</code> module and platform intrinsics.</p>
<h2 id="atomics" class="section-header"><a href="#atomics">Atomics</a></h2>
<p>The <a href="https://github.com/webassembly/threads">threads proposal</a> for WebAssembly adds a number of
instructions for dealing with multithreaded programs. Atomic
instructions can all be generated through <code>std::sync::atomic</code> types, but
some instructions have no equivalent in Rust such as
<code>memory.atomic.notify</code> so this module will provide these intrinsics.</p>
<p>At this time, however, these intrinsics are only available <strong>when the
standard library itself is compiled with atomics</strong>. Compiling with
atomics is not enabled by default and requires passing
<code>-Ctarget-feature=+atomics</code> to rustc. The standard library shipped via
<code>rustup</code> is not compiled with atomics. To get access to these intrinsics
you’ll need to compile the standard library from source with the
requisite compiler flags.</p>
<h2 id="simd" class="section-header"><a href="#simd">SIMD</a></h2>
<p>The <a href="https://github.com/webassembly/simd">simd proposal</a> for WebAssembly adds a new <code>v128</code> type for a
128-bit SIMD register. It also adds a large array of instructions to
operate on the <code>v128</code> type to perform data processing. The SIMD proposal
has been in progress for quite some time and many instructions have come
and gone. This module attempts to keep up with the proposal, but if you
notice anything awry please feel free to <a href="https://github.com/rust-lang/stdarch/issues/new">open an
issue</a>.</p>
<p>It’s important to be aware that the current state of development of SIMD
in WebAssembly is still somewhat early days. There’s lots of pieces to
demo and prototype with, but discussions and support are still in
progress. There’s a number of pitfalls and gotchas in various places,
which will attempt to be documented here, but there may be others
lurking!</p>
<p>Using SIMD is intended to be similar to as you would on <code>x86_64</code>, for
example. You’d write a function such as:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;wasm32&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">target_feature</span>(<span class="ident">enable</span> <span class="op">=</span> <span class="string">&quot;simd128&quot;</span>)]</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">uses_simd</span>() {
    <span class="kw">use</span> <span class="ident">std::arch::wasm32</span>::<span class="kw-2">*</span>;
    <span class="comment">// ...</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0A%23%5Bcfg(target_arch%20%3D%20%22wasm32%22)%5D%0A%23%5Btarget_feature(enable%20%3D%20%22simd128%22)%5D%0Aunsafe%20fn%20uses_simd()%20%7B%0A%20%20%20%20use%20std%3A%3Aarch%3A%3Awasm32%3A%3A*%3B%0A%20%20%20%20%2F%2F%20...%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>Unlike <code>x86_64</code>, however, WebAssembly does not currently have dynamic
detection at runtime as to whether SIMD is supported (this is one of the
motivators for the <a href="https://github.com/webassembly/conditional-sections">conditional sections proposal</a>, but
that is still pretty early days). This means that your binary will
either have SIMD and can only run on engines which support SIMD, or it
will not have SIMD at all. For compatibility the standard library itself
does not use any SIMD internally. Determining how best to ship your
WebAssembly binary with SIMD is largely left up to you as it can can be
pretty nuanced depending on your situation.</p>
<p>To enable SIMD support at compile time you need to do one of two things:</p>
<ul>
<li>
<p>First you can annotate functions with <code>#[target_feature(enable = &quot;simd128&quot;)]</code>. This causes just that one function to have SIMD support
available to it, and intrinsics will get inlined as usual in this
situation.</p>
</li>
<li>
<p>Second you can compile your program with <code>-Ctarget-feature=+simd128</code>.
This compilation flag blanket enables SIMD support for your entire
compilation. Note that this does not include the standard library
unless you recompile the standard library.</p>
</li>
</ul>
<p>If you enable SIMD via either of these routes then you’ll have a
WebAssembly binary that uses SIMD instructions, and you’ll need to ship
that accordingly. Also note that if you call SIMD intrinsics but don’t
enable SIMD via either of these mechanisms, you’ll still have SIMD
generated in your program. This means to generate a binary without SIMD
you’ll need to avoid both options above plus calling into any intrinsics
in this module.</p>
<blockquote>
<p><strong>Note</strong>: Due to
<a href="https://github.com/rust-lang/rust/issues/74320">rust-lang/rust#74320</a>
it’s recommended to compile your entire program with SIMD support
(using <code>RUSTFLAGS</code>) or otherwise functions may not be inlined
correctly.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: LLVM’s SIMD support is actually split into two features:
<code>simd128</code> and <code>unimplemented-simd128</code>. Rust code can enable <code>simd128</code>
with <code>#[target_feature]</code> (and test for it with <code>#[cfg(target_feature = &quot;simd128&quot;)]</code>, but it cannot enable <code>unimplemented-simd128</code>. The only
way to enable this feature is to compile with
<code>-Ctarget-feature=+simd128,+unimplemented-simd128</code>. This second
feature enables more recent instructions implemented in LLVM which
haven’t always had enough time to make their way to runtimes.</p>
</blockquote>
</div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="unstable module-item"><td><a class="struct" href="struct.v128.html" title="core::arch::wasm32::v128 struct">v128</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>WASM-specific 128-bit wide SIMD vector type.</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_abs.html" title="core::arch::wasm32::f32x4_abs fn">f32x4_abs</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Calculates the absolute value of each lane of a 128-bit vector interpreted
as four 32-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_add.html" title="core::arch::wasm32::f32x4_add fn">f32x4_add</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds pairwise lanes of two 128-bit vectors interpreted as four 32-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_const.html" title="core::arch::wasm32::f32x4_const fn">f32x4_const</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Materializes a constant SIMD value from the immediate operands.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_convert_i32x4_s.html" title="core::arch::wasm32::f32x4_convert_i32x4_s fn">f32x4_convert_i32x4_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Converts a 128-bit vector interpreted as four 32-bit signed integers into a
128-bit vector of four 32-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_convert_i32x4_u.html" title="core::arch::wasm32::f32x4_convert_i32x4_u fn">f32x4_convert_i32x4_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Converts a 128-bit vector interpreted as four 32-bit unsigned integers into a
128-bit vector of four 32-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_div.html" title="core::arch::wasm32::f32x4_div fn">f32x4_div</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Divides pairwise lanes of two 128-bit vectors interpreted as four 32-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_eq.html" title="core::arch::wasm32::f32x4_eq fn">f32x4_eq</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_extract_lane.html" title="core::arch::wasm32::f32x4_extract_lane fn">f32x4_extract_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Extracts a lane from a 128-bit vector interpreted as 4 packed f32 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_ge.html" title="core::arch::wasm32::f32x4_ge fn">f32x4_ge</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_gt.html" title="core::arch::wasm32::f32x4_gt fn">f32x4_gt</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_le.html" title="core::arch::wasm32::f32x4_le fn">f32x4_le</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_lt.html" title="core::arch::wasm32::f32x4_lt fn">f32x4_lt</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_max.html" title="core::arch::wasm32::f32x4_max fn">f32x4_max</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Calculates the maximum of pairwise lanes of two 128-bit vectors interpreted
as four 32-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_min.html" title="core::arch::wasm32::f32x4_min fn">f32x4_min</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Calculates the minimum of pairwise lanes of two 128-bit vectors interpreted
as four 32-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_mul.html" title="core::arch::wasm32::f32x4_mul fn">f32x4_mul</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Multiplies pairwise lanes of two 128-bit vectors interpreted as four 32-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_ne.html" title="core::arch::wasm32::f32x4_ne fn">f32x4_ne</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_neg.html" title="core::arch::wasm32::f32x4_neg fn">f32x4_neg</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Negates each lane of a 128-bit vector interpreted as four 32-bit floating
point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_replace_lane.html" title="core::arch::wasm32::f32x4_replace_lane fn">f32x4_replace_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Replaces a lane from a 128-bit vector interpreted as 4 packed f32 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_splat.html" title="core::arch::wasm32::f32x4_splat fn">f32x4_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Creates a vector with identical lanes.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_sqrt.html" title="core::arch::wasm32::f32x4_sqrt fn">f32x4_sqrt</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Calculates the square root of each lane of a 128-bit vector interpreted as
four 32-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f32x4_sub.html" title="core::arch::wasm32::f32x4_sub fn">f32x4_sub</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts pairwise lanes of two 128-bit vectors interpreted as four 32-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_abs.html" title="core::arch::wasm32::f64x2_abs fn">f64x2_abs</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Calculates the absolute value of each lane of a 128-bit vector interpreted
as two 64-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_add.html" title="core::arch::wasm32::f64x2_add fn">f64x2_add</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds pairwise lanes of two 128-bit vectors interpreted as two 64-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_const.html" title="core::arch::wasm32::f64x2_const fn">f64x2_const</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Materializes a constant SIMD value from the immediate operands.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_div.html" title="core::arch::wasm32::f64x2_div fn">f64x2_div</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Divides pairwise lanes of two 128-bit vectors interpreted as two 64-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_eq.html" title="core::arch::wasm32::f64x2_eq fn">f64x2_eq</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_extract_lane.html" title="core::arch::wasm32::f64x2_extract_lane fn">f64x2_extract_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Extracts a lane from a 128-bit vector interpreted as 2 packed f64 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_ge.html" title="core::arch::wasm32::f64x2_ge fn">f64x2_ge</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_gt.html" title="core::arch::wasm32::f64x2_gt fn">f64x2_gt</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_le.html" title="core::arch::wasm32::f64x2_le fn">f64x2_le</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_lt.html" title="core::arch::wasm32::f64x2_lt fn">f64x2_lt</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_max.html" title="core::arch::wasm32::f64x2_max fn">f64x2_max</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Calculates the maximum of pairwise lanes of two 128-bit vectors interpreted
as two 64-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_min.html" title="core::arch::wasm32::f64x2_min fn">f64x2_min</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Calculates the minimum of pairwise lanes of two 128-bit vectors interpreted
as two 64-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_mul.html" title="core::arch::wasm32::f64x2_mul fn">f64x2_mul</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Multiplies pairwise lanes of two 128-bit vectors interpreted as two 64-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_ne.html" title="core::arch::wasm32::f64x2_ne fn">f64x2_ne</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_neg.html" title="core::arch::wasm32::f64x2_neg fn">f64x2_neg</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Negates each lane of a 128-bit vector interpreted as two 64-bit floating
point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_replace_lane.html" title="core::arch::wasm32::f64x2_replace_lane fn">f64x2_replace_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Replaces a lane from a 128-bit vector interpreted as 2 packed f64 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_splat.html" title="core::arch::wasm32::f64x2_splat fn">f64x2_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Creates a vector with identical lanes.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_sqrt.html" title="core::arch::wasm32::f64x2_sqrt fn">f64x2_sqrt</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Calculates the square root of each lane of a 128-bit vector interpreted as
two 64-bit floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.f64x2_sub.html" title="core::arch::wasm32::f64x2_sub fn">f64x2_sub</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts pairwise lanes of two 128-bit vectors interpreted as two 64-bit
floating point numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_abs.html" title="core::arch::wasm32::i8x16_abs fn">i8x16_abs</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Lane-wise wrapping absolute value.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_add.html" title="core::arch::wasm32::i8x16_add fn">i8x16_add</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds two 128-bit vectors as if they were two packed sixteen 8-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_add_saturate_s.html" title="core::arch::wasm32::i8x16_add_saturate_s fn">i8x16_add_saturate_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds two 128-bit vectors as if they were two packed sixteen 8-bit signed
integers, saturating on overflow to <code>i8::MAX</code>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_add_saturate_u.html" title="core::arch::wasm32::i8x16_add_saturate_u fn">i8x16_add_saturate_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds two 128-bit vectors as if they were two packed sixteen 8-bit unsigned
integers, saturating on overflow to <code>u8::MAX</code>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_all_true.html" title="core::arch::wasm32::i8x16_all_true fn">i8x16_all_true</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Returns 1 if all lanes are nonzero or 0 if any lane is nonzero.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_any_true.html" title="core::arch::wasm32::i8x16_any_true fn">i8x16_any_true</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Returns 1 if any lane is nonzero or 0 if all lanes are zero.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_avgr_u.html" title="core::arch::wasm32::i8x16_avgr_u fn">i8x16_avgr_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Lane-wise rounding average.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_const.html" title="core::arch::wasm32::i8x16_const fn">i8x16_const</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Materializes a constant SIMD value from the immediate operands.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_eq.html" title="core::arch::wasm32::i8x16_eq fn">i8x16_eq</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_extract_lane.html" title="core::arch::wasm32::i8x16_extract_lane fn">i8x16_extract_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Extracts a lane from a 128-bit vector interpreted as 16 packed i8 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_ge_s.html" title="core::arch::wasm32::i8x16_ge_s fn">i8x16_ge_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_ge_u.html" title="core::arch::wasm32::i8x16_ge_u fn">i8x16_ge_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_gt_s.html" title="core::arch::wasm32::i8x16_gt_s fn">i8x16_gt_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_gt_u.html" title="core::arch::wasm32::i8x16_gt_u fn">i8x16_gt_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_le_s.html" title="core::arch::wasm32::i8x16_le_s fn">i8x16_le_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_le_u.html" title="core::arch::wasm32::i8x16_le_u fn">i8x16_le_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_lt_s.html" title="core::arch::wasm32::i8x16_lt_s fn">i8x16_lt_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_lt_u.html" title="core::arch::wasm32::i8x16_lt_u fn">i8x16_lt_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_max_s.html" title="core::arch::wasm32::i8x16_max_s fn">i8x16_max_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise signed integers, and returns the maximum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_max_u.html" title="core::arch::wasm32::i8x16_max_u fn">i8x16_max_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise unsigned integers, and returns the maximum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_min_s.html" title="core::arch::wasm32::i8x16_min_s fn">i8x16_min_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise signed integers, and returns the minimum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_min_u.html" title="core::arch::wasm32::i8x16_min_u fn">i8x16_min_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise unsigned integers, and returns the minimum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_narrow_i16x8_s.html" title="core::arch::wasm32::i8x16_narrow_i16x8_s fn">i8x16_narrow_i16x8_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Converts two input vectors into a smaller lane vector by narrowing each
lane.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_narrow_i16x8_u.html" title="core::arch::wasm32::i8x16_narrow_i16x8_u fn">i8x16_narrow_i16x8_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Converts two input vectors into a smaller lane vector by narrowing each
lane.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_ne.html" title="core::arch::wasm32::i8x16_ne fn">i8x16_ne</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 16 eight-bit
integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_neg.html" title="core::arch::wasm32::i8x16_neg fn">i8x16_neg</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Negates a 128-bit vectors intepreted as sixteen 8-bit signed integers</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_replace_lane.html" title="core::arch::wasm32::i8x16_replace_lane fn">i8x16_replace_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Replaces a lane from a 128-bit vector interpreted as 16 packed i8 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_shl.html" title="core::arch::wasm32::i8x16_shl fn">i8x16_shl</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the left by the specified number of bits.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_shr_s.html" title="core::arch::wasm32::i8x16_shr_s fn">i8x16_shr_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the right by the specified number of bits, sign
extending.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_shr_u.html" title="core::arch::wasm32::i8x16_shr_u fn">i8x16_shr_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the right by the specified number of bits, shifting in
zeros.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_splat.html" title="core::arch::wasm32::i8x16_splat fn">i8x16_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Creates a vector with identical lanes.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_sub.html" title="core::arch::wasm32::i8x16_sub fn">i8x16_sub</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_sub_saturate_s.html" title="core::arch::wasm32::i8x16_sub_saturate_s fn">i8x16_sub_saturate_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit
signed integers, saturating on overflow to <code>i8::MIN</code>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i8x16_sub_saturate_u.html" title="core::arch::wasm32::i8x16_sub_saturate_u fn">i8x16_sub_saturate_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit
unsigned integers, saturating on overflow to 0.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_abs.html" title="core::arch::wasm32::i16x8_abs fn">i16x8_abs</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Lane-wise wrapping absolute value.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_add.html" title="core::arch::wasm32::i16x8_add fn">i16x8_add</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds two 128-bit vectors as if they were two packed eight 16-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_add_saturate_s.html" title="core::arch::wasm32::i16x8_add_saturate_s fn">i16x8_add_saturate_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds two 128-bit vectors as if they were two packed eight 16-bit signed
integers, saturating on overflow to <code>i16::MAX</code>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_add_saturate_u.html" title="core::arch::wasm32::i16x8_add_saturate_u fn">i16x8_add_saturate_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds two 128-bit vectors as if they were two packed eight 16-bit unsigned
integers, saturating on overflow to <code>u16::MAX</code>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_all_true.html" title="core::arch::wasm32::i16x8_all_true fn">i16x8_all_true</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Returns 1 if all lanes are nonzero or 0 if any lane is nonzero.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_any_true.html" title="core::arch::wasm32::i16x8_any_true fn">i16x8_any_true</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Returns 1 if any lane is nonzero or 0 if all lanes are zero.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_avgr_u.html" title="core::arch::wasm32::i16x8_avgr_u fn">i16x8_avgr_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Lane-wise rounding average.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_const.html" title="core::arch::wasm32::i16x8_const fn">i16x8_const</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Materializes a constant SIMD value from the immediate operands.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_eq.html" title="core::arch::wasm32::i16x8_eq fn">i16x8_eq</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_extract_lane.html" title="core::arch::wasm32::i16x8_extract_lane fn">i16x8_extract_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Extracts a lane from a 128-bit vector interpreted as 8 packed i16 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_ge_s.html" title="core::arch::wasm32::i16x8_ge_s fn">i16x8_ge_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_ge_u.html" title="core::arch::wasm32::i16x8_ge_u fn">i16x8_ge_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_gt_s.html" title="core::arch::wasm32::i16x8_gt_s fn">i16x8_gt_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_gt_u.html" title="core::arch::wasm32::i16x8_gt_u fn">i16x8_gt_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_le_s.html" title="core::arch::wasm32::i16x8_le_s fn">i16x8_le_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_le_u.html" title="core::arch::wasm32::i16x8_le_u fn">i16x8_le_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_load8x8_s.html" title="core::arch::wasm32::i16x8_load8x8_s fn">i16x8_load8x8_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load eight 8-bit integers and sign extend each one to a 16-bit lane</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_load8x8_u.html" title="core::arch::wasm32::i16x8_load8x8_u fn">i16x8_load8x8_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load eight 8-bit integers and zero extend each one to a 16-bit lane</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_lt_s.html" title="core::arch::wasm32::i16x8_lt_s fn">i16x8_lt_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_lt_u.html" title="core::arch::wasm32::i16x8_lt_u fn">i16x8_lt_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_max_s.html" title="core::arch::wasm32::i16x8_max_s fn">i16x8_max_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise signed integers, and returns the maximum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_max_u.html" title="core::arch::wasm32::i16x8_max_u fn">i16x8_max_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise unsigned integers, and returns the maximum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_min_s.html" title="core::arch::wasm32::i16x8_min_s fn">i16x8_min_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise signed integers, and returns the minimum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_min_u.html" title="core::arch::wasm32::i16x8_min_u fn">i16x8_min_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise unsigned integers, and returns the minimum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_mul.html" title="core::arch::wasm32::i16x8_mul fn">i16x8_mul</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Multiplies two 128-bit vectors as if they were two packed eight 16-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_narrow_i32x4_s.html" title="core::arch::wasm32::i16x8_narrow_i32x4_s fn">i16x8_narrow_i32x4_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Converts two input vectors into a smaller lane vector by narrowing each
lane.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_narrow_i32x4_u.html" title="core::arch::wasm32::i16x8_narrow_i32x4_u fn">i16x8_narrow_i32x4_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Converts two input vectors into a smaller lane vector by narrowing each
lane.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_ne.html" title="core::arch::wasm32::i16x8_ne fn">i16x8_ne</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit
integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_neg.html" title="core::arch::wasm32::i16x8_neg fn">i16x8_neg</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Negates a 128-bit vectors intepreted as eight 16-bit signed integers</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_replace_lane.html" title="core::arch::wasm32::i16x8_replace_lane fn">i16x8_replace_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Replaces a lane from a 128-bit vector interpreted as 8 packed i16 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_shl.html" title="core::arch::wasm32::i16x8_shl fn">i16x8_shl</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the left by the specified number of bits.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_shr_s.html" title="core::arch::wasm32::i16x8_shr_s fn">i16x8_shr_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the right by the specified number of bits, sign
extending.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_shr_u.html" title="core::arch::wasm32::i16x8_shr_u fn">i16x8_shr_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the right by the specified number of bits, shifting in
zeros.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_splat.html" title="core::arch::wasm32::i16x8_splat fn">i16x8_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Creates a vector with identical lanes.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_sub.html" title="core::arch::wasm32::i16x8_sub fn">i16x8_sub</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts two 128-bit vectors as if they were two packed eight 16-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_sub_saturate_s.html" title="core::arch::wasm32::i16x8_sub_saturate_s fn">i16x8_sub_saturate_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts two 128-bit vectors as if they were two packed eight 16-bit
signed integers, saturating on overflow to <code>i16::MIN</code>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_sub_saturate_u.html" title="core::arch::wasm32::i16x8_sub_saturate_u fn">i16x8_sub_saturate_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts two 128-bit vectors as if they were two packed eight 16-bit
unsigned integers, saturating on overflow to 0.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_widen_high_i8x16_s.html" title="core::arch::wasm32::i16x8_widen_high_i8x16_s fn">i16x8_widen_high_i8x16_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Converts high half of the smaller lane vector to a larger lane
vector, sign extended.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_widen_high_i8x16_u.html" title="core::arch::wasm32::i16x8_widen_high_i8x16_u fn">i16x8_widen_high_i8x16_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Converts high half of the smaller lane vector to a larger lane
vector, zero extended.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_widen_low_i8x16_s.html" title="core::arch::wasm32::i16x8_widen_low_i8x16_s fn">i16x8_widen_low_i8x16_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Converts low half of the smaller lane vector to a larger lane
vector, sign extended.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i16x8_widen_low_i8x16_u.html" title="core::arch::wasm32::i16x8_widen_low_i8x16_u fn">i16x8_widen_low_i8x16_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Converts low half of the smaller lane vector to a larger lane
vector, zero extended.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_abs.html" title="core::arch::wasm32::i32x4_abs fn">i32x4_abs</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Lane-wise wrapping absolute value.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_add.html" title="core::arch::wasm32::i32x4_add fn">i32x4_add</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds two 128-bit vectors as if they were two packed four 32-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_all_true.html" title="core::arch::wasm32::i32x4_all_true fn">i32x4_all_true</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Returns 1 if all lanes are nonzero or 0 if any lane is nonzero.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_any_true.html" title="core::arch::wasm32::i32x4_any_true fn">i32x4_any_true</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Returns 1 if any lane is nonzero or 0 if all lanes are zero.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_const.html" title="core::arch::wasm32::i32x4_const fn">i32x4_const</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Materializes a constant SIMD value from the immediate operands.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_eq.html" title="core::arch::wasm32::i32x4_eq fn">i32x4_eq</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_extract_lane.html" title="core::arch::wasm32::i32x4_extract_lane fn">i32x4_extract_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Extracts a lane from a 128-bit vector interpreted as 4 packed i32 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_ge_s.html" title="core::arch::wasm32::i32x4_ge_s fn">i32x4_ge_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_ge_u.html" title="core::arch::wasm32::i32x4_ge_u fn">i32x4_ge_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_gt_s.html" title="core::arch::wasm32::i32x4_gt_s fn">i32x4_gt_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_gt_u.html" title="core::arch::wasm32::i32x4_gt_u fn">i32x4_gt_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_le_s.html" title="core::arch::wasm32::i32x4_le_s fn">i32x4_le_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_le_u.html" title="core::arch::wasm32::i32x4_le_u fn">i32x4_le_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_load16x4_s.html" title="core::arch::wasm32::i32x4_load16x4_s fn">i32x4_load16x4_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load four 16-bit integers and sign extend each one to a 32-bit lane</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_load16x4_u.html" title="core::arch::wasm32::i32x4_load16x4_u fn">i32x4_load16x4_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load four 16-bit integers and zero extend each one to a 32-bit lane</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_lt_s.html" title="core::arch::wasm32::i32x4_lt_s fn">i32x4_lt_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_lt_u.html" title="core::arch::wasm32::i32x4_lt_u fn">i32x4_lt_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_max_s.html" title="core::arch::wasm32::i32x4_max_s fn">i32x4_max_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise signed integers, and returns the maximum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_max_u.html" title="core::arch::wasm32::i32x4_max_u fn">i32x4_max_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise unsigned integers, and returns the maximum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_min_s.html" title="core::arch::wasm32::i32x4_min_s fn">i32x4_min_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise signed integers, and returns the minimum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_min_u.html" title="core::arch::wasm32::i32x4_min_u fn">i32x4_min_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares lane-wise unsigned integers, and returns the minimum of
each pair.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_mul.html" title="core::arch::wasm32::i32x4_mul fn">i32x4_mul</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Multiplies two 128-bit vectors as if they were two packed four 32-bit
signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_ne.html" title="core::arch::wasm32::i32x4_ne fn">i32x4_ne</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit
integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_neg.html" title="core::arch::wasm32::i32x4_neg fn">i32x4_neg</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Negates a 128-bit vectors intepreted as four 32-bit signed integers</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_replace_lane.html" title="core::arch::wasm32::i32x4_replace_lane fn">i32x4_replace_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Replaces a lane from a 128-bit vector interpreted as 4 packed i32 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_shl.html" title="core::arch::wasm32::i32x4_shl fn">i32x4_shl</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the left by the specified number of bits.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_shr_s.html" title="core::arch::wasm32::i32x4_shr_s fn">i32x4_shr_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the right by the specified number of bits, sign
extending.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_shr_u.html" title="core::arch::wasm32::i32x4_shr_u fn">i32x4_shr_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the right by the specified number of bits, shifting in
zeros.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_splat.html" title="core::arch::wasm32::i32x4_splat fn">i32x4_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Creates a vector with identical lanes.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_sub.html" title="core::arch::wasm32::i32x4_sub fn">i32x4_sub</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts two 128-bit vectors as if they were two packed four 32-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_trunc_sat_f32x4_s.html" title="core::arch::wasm32::i32x4_trunc_sat_f32x4_s fn">i32x4_trunc_sat_f32x4_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Converts a 128-bit vector interpreted as four 32-bit floating point numbers
into a 128-bit vector of four 32-bit signed integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_trunc_sat_f32x4_u.html" title="core::arch::wasm32::i32x4_trunc_sat_f32x4_u fn">i32x4_trunc_sat_f32x4_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Converts a 128-bit vector interpreted as four 32-bit floating point numbers
into a 128-bit vector of four 32-bit unsigned integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_widen_high_i16x8_s.html" title="core::arch::wasm32::i32x4_widen_high_i16x8_s fn">i32x4_widen_high_i16x8_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Converts high half of the smaller lane vector to a larger lane
vector, sign extended.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_widen_high_i16x8_u.html" title="core::arch::wasm32::i32x4_widen_high_i16x8_u fn">i32x4_widen_high_i16x8_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Converts high half of the smaller lane vector to a larger lane
vector, zero extended.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_widen_low_i16x8_s.html" title="core::arch::wasm32::i32x4_widen_low_i16x8_s fn">i32x4_widen_low_i16x8_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Converts low half of the smaller lane vector to a larger lane
vector, sign extended.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i32x4_widen_low_i16x8_u.html" title="core::arch::wasm32::i32x4_widen_low_i16x8_u fn">i32x4_widen_low_i16x8_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Converts low half of the smaller lane vector to a larger lane
vector, zero extended.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_add.html" title="core::arch::wasm32::i64x2_add fn">i64x2_add</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Adds two 128-bit vectors as if they were two packed two 64-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_const.html" title="core::arch::wasm32::i64x2_const fn">i64x2_const</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Materializes a constant SIMD value from the immediate operands.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_extract_lane.html" title="core::arch::wasm32::i64x2_extract_lane fn">i64x2_extract_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Extracts a lane from a 128-bit vector interpreted as 2 packed i64 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_load32x2_s.html" title="core::arch::wasm32::i64x2_load32x2_s fn">i64x2_load32x2_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load two 32-bit integers and sign extend each one to a 64-bit lane</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_load32x2_u.html" title="core::arch::wasm32::i64x2_load32x2_u fn">i64x2_load32x2_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load two 32-bit integers and zero extend each one to a 64-bit lane</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_mul.html" title="core::arch::wasm32::i64x2_mul fn">i64x2_mul</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Multiplies two 128-bit vectors as if they were two packed two 64-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_neg.html" title="core::arch::wasm32::i64x2_neg fn">i64x2_neg</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Negates a 128-bit vectors intepreted as two 64-bit signed integers</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_replace_lane.html" title="core::arch::wasm32::i64x2_replace_lane fn">i64x2_replace_lane</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Replaces a lane from a 128-bit vector interpreted as 2 packed i64 numbers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_shl.html" title="core::arch::wasm32::i64x2_shl fn">i64x2_shl</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the left by the specified number of bits.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_shr_s.html" title="core::arch::wasm32::i64x2_shr_s fn">i64x2_shr_s</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the right by the specified number of bits, sign
extending.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_shr_u.html" title="core::arch::wasm32::i64x2_shr_u fn">i64x2_shr_u</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Shifts each lane to the right by the specified number of bits, shifting in
zeros.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_splat.html" title="core::arch::wasm32::i64x2_splat fn">i64x2_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Creates a vector with identical lanes.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.i64x2_sub.html" title="core::arch::wasm32::i64x2_sub fn">i64x2_sub</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Subtracts two 128-bit vectors as if they were two packed two 64-bit integers.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.memory_atomic_notify.html" title="core::arch::wasm32::memory_atomic_notify fn">memory_atomic_notify</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Corresponding intrinsic to wasm’s <a href="https://webassembly.github.io/threads/syntax/instructions.html#syntax-instr-atomic-memory"><code>memory.atomic.notify</code> instruction</a></p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.memory_atomic_wait32.html" title="core::arch::wasm32::memory_atomic_wait32 fn">memory_atomic_wait32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Corresponding intrinsic to wasm’s <a href="https://webassembly.github.io/threads/syntax/instructions.html#syntax-instr-atomic-memory"><code>memory.atomic.wait32</code> instruction</a></p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.memory_atomic_wait64.html" title="core::arch::wasm32::memory_atomic_wait64 fn">memory_atomic_wait64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Corresponding intrinsic to wasm’s <a href="https://webassembly.github.io/threads/syntax/instructions.html#syntax-instr-atomic-memory"><code>memory.atomic.wait64</code> instruction</a></p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v8x16_load_splat.html" title="core::arch::wasm32::v8x16_load_splat fn">v8x16_load_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load a single element and splat to all lanes of a v128 vector.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v8x16_shuffle.html" title="core::arch::wasm32::v8x16_shuffle fn">v8x16_shuffle</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Returns a new vector with lanes selected from the lanes of the two input
vectors <code>$a</code> and <code>$b</code> specified in the 16 immediate operands.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v8x16_swizzle.html" title="core::arch::wasm32::v8x16_swizzle fn">v8x16_swizzle</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Returns a new vector with lanes selected from the lanes of the first input
vector <code>a</code> specified in the second input vector <code>s</code>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v16x8_load_splat.html" title="core::arch::wasm32::v16x8_load_splat fn">v16x8_load_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load a single element and splat to all lanes of a v128 vector.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v16x8_shuffle.html" title="core::arch::wasm32::v16x8_shuffle fn">v16x8_shuffle</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Same as <a href="fn.v8x16_shuffle.html" title="v8x16_shuffle"><code>v8x16_shuffle</code></a>, except operates as if the inputs were eight
16-bit integers, only taking 8 indices to shuffle.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v32x4_load_splat.html" title="core::arch::wasm32::v32x4_load_splat fn">v32x4_load_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load a single element and splat to all lanes of a v128 vector.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v32x4_shuffle.html" title="core::arch::wasm32::v32x4_shuffle fn">v32x4_shuffle</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Same as <a href="fn.v8x16_shuffle.html" title="v8x16_shuffle"><code>v8x16_shuffle</code></a>, except operates as if the inputs were four
32-bit integers, only taking 4 indices to shuffle.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v64x2_load_splat.html" title="core::arch::wasm32::v64x2_load_splat fn">v64x2_load_splat</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Load a single element and splat to all lanes of a v128 vector.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v64x2_shuffle.html" title="core::arch::wasm32::v64x2_shuffle fn">v64x2_shuffle</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Same as <a href="fn.v8x16_shuffle.html" title="v8x16_shuffle"><code>v8x16_shuffle</code></a>, except operates as if the inputs were two
64-bit integers, only taking 2 indices to shuffle.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v128_and.html" title="core::arch::wasm32::v128_and fn">v128_and</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Performs a bitwise and of the two input 128-bit vectors, returning the
resulting vector.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v128_andnot.html" title="core::arch::wasm32::v128_andnot fn">v128_andnot</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Bitwise AND of bits of <code>a</code> and the logical inverse of bits of <code>b</code>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v128_bitselect.html" title="core::arch::wasm32::v128_bitselect fn">v128_bitselect</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Use the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> when 0.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v128_load.html" title="core::arch::wasm32::v128_load fn">v128_load</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Loads a <code>v128</code> vector from the given heap address.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v128_not.html" title="core::arch::wasm32::v128_not fn">v128_not</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Flips each bit of the 128-bit input vector.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v128_or.html" title="core::arch::wasm32::v128_or fn">v128_or</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Performs a bitwise or of the two input 128-bit vectors, returning the
resulting vector.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v128_store.html" title="core::arch::wasm32::v128_store fn">v128_store</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Stores a <code>v128</code> vector to the given heap address.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.v128_xor.html" title="core::arch::wasm32::v128_xor fn">v128_xor</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `simd128` only"><code>simd128</code></span><p>Performs a bitwise xor of the two input 128-bit vectors, returning the
resulting vector.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.memory_grow.html" title="core::arch::wasm32::memory_grow fn">memory_grow</a></td><td class="docblock-short"><p>Corresponding intrinsic to wasm’s <a href="http://webassembly.github.io/spec/core/exec/instructions.html#exec-memory-grow"><code>memory.grow</code> instruction</a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.memory_size.html" title="core::arch::wasm32::memory_size fn">memory_size</a></td><td class="docblock-short"><p>Corresponding intrinsic to wasm’s <a href="http://webassembly.github.io/spec/core/exec/instructions.html#exec-memory-size"><code>memory.size</code> instruction</a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.unreachable.html" title="core::arch::wasm32::unreachable fn">unreachable</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>Generates the trap instruction <code>UNREACHABLE</code></p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="core" data-search-index-js="../../../search-index1.53.0.js" data-search-js="../../../search1.53.0.js"></div>
    <script src="../../../main1.53.0.js"></script></body></html>